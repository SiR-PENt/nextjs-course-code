import MeetupList from "../components/meetups/MeetupList";
import { MongoClient } from "mongodb";//this package imported here will not be exposed to the client-side if we are only using it in the server-side 
import { Fragment } from "react";
import Head from 'next/head'


function HomePage(props) {

    //after useEffect updates state, whole component rerenders bcos state changed.

    // NB: Because of this two render cycles, we have a problem with search engine optimization.  

    // WHY?

    // Because on inspection of the page source, we get an empty undeordered list(from meetuplist) because state was initially an empty array on the first load. 

    // This is because the prerendered HTML page generated by nextjs does not wait for the second cycle and that's where page pre-rendering comes in

    //For example, we send a request to a page '/some-route', we get a pre-rendered page which might be missing data. After the page was received, react takes over(hydrates the page) i.e react turns it into a spa and then useEffect function might be run. But this will be run on the browser, on the client-side. NOT ON THE SERVER, which is really bad for SEO.
    
    //Now, for we to get this data pre-rendered(i.e from the server directly), we need to fine-tune the pre-rendering process. 
    
    //NEXTjs though solves this p. NextJs provides two forms of pre-rendering. 
    
    //1. Static generation 
    //2. Server-side rendering

    //When using Static generation, page component is pre-rendered when you build your app(when you as a dev build your nextapp for prod). Like running `npm run build`. NextJS by default generates your pages statically and it does that by default during the build process. But if we need to wait for data(i.e data fetching) we can do so by exporting a special func, *getStaticProps*(and it has to be called that) from inside page component files. Works only in files inside the pages folder.

    //NextJS will look for a function with that name(getStaticProps), and if it finds it, it runs it first before runing the component function. *getStaticprops* indeed has that name, because it's function is to provide a props for that page which contains the data that the page might use.
    
    //Now, one key feature of the getStaticProps is that it's can be async. You can return a promise there. NextJs will wait for the promise to resolve,(i.e for when the data is loaded) and then return props for the component function, that way the component is able to load data before it's function is executed. So the component can be rendered with the required data. Get it? 

    //Code that can be run in the getStaticProps are standard server-side code. This code will never end up on the client side and will never execute on the client side because it is executed during the build process not on the server and especially not on the client-side. You can fetch data from a database or API in the code. But whatever you do, you need to return an object, inside the object, you set a prop ppt in there, which also has to be named props, the props ppt also hold another obj which is the props obj you receive in your page component func. (i.e it will be the props of the component), now as a result, we no longer need useEffect and useState

    // NB: running `npm run build` for this app, we get 4 pages(which are from the pages folder). 3 pages in the pages folder plus a custom 404 page.
    
    //WHAT I UNDERSTAND BY GETSTATICPROPS
    // You have to run build everytime data is changed. To automatically run build everytime in the server, we unlock a feature called incremental static generation
    return (
      <Fragment>
        <Head>
          <title>React Meetups</title>
          <meta name='description' content='Browse a huge list of highly active React meetups'/> 
        </Head>
           <MeetupList meetups={props.meetups} />
      </Fragment>
    );       
}

export async function getStaticProps() {

   const client = await MongoClient.connect('mongodb+srv://SiRPENt:&unkanm1@cluster0.yqbu3.mongodb.net/meetups?retryWrites=true&w=majority')
   const db = client.db();
   const meetupsCollection = db.collection('meetups');
   const meetups = await meetupsCollection.find().toArray();// find meetupsCollection data and convert promise return to array
   client.close()

  return {
    props: {
      meetups: meetups.map(meetup => ({ 
        title: meetup.title,
        address: meetup.address,
        image: meetup.image,
        id:meetup._id.toString(),//convert meetup to string so it's useable
      })),
    }, 
    revalidate:10,
  }
}
export default HomePage;